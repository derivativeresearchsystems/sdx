package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/mhausenblas/kubecuddler"
)

// ensure checks if, depending on the status, the remote or local
// clusters are set up correctly, for example, the namespace exists.
func ensure(withstderr, verbose bool, namespace, status, clocal, cremote string) error {
	switch status {
	case StatusOffline:
		displayinfo(fmt.Sprintf("Checking if local context [%v] is ready", clocal))
		// make sure that if the namespace exists we re-create it:
		_, err := kubecuddler.Kubectl(withstderr, verbose, kubectlbin, "get", "namespace", namespace)
		if err == nil {
			_, err := kubecuddler.Kubectl(false, verbose, kubectlbin, "delete", "namespace", namespace)
			if err != nil {
				return err
			}
		}
		_, err = kubecuddler.Kubectl(false, verbose, kubectlbin, "create", "namespace", namespace)
		if err != nil {
			return err
		}
		displayinfo(fmt.Sprintf("Recreated namespace %v in local context", namespace))
	case StatusOnline:
		fmt.Printf("Attempting to switch to %v, checking if remote cluster is available and ready\n", cremote)
	}
	return nil
}

// capture queries the current state in the active namespace by exporting
// the state of deployments and services as a YAML doc
func capture(withstderr, verbose bool, namespace, resources string) (string, error) {
	yamldoc := "# This file has been automatically generated by kube-sdx\n\n---\n"
	if !strings.Contains(resources, ",") {
		return "", fmt.Errorf("Invalid resource list, must be of format: '$RESOURCE_KIND1,$RESOURCE_KIND2,...'")
	}
	resourcelist := strings.Split(resources, ",")
	for _, reskind := range resourcelist {
		reskind = strings.TrimSpace(reskind)
		yamlfrag, err := kubecuddler.Kubectl(withstderr, verbose, kubectlbin, "get", "--namespace="+namespace, reskind, "--export", "--output=yaml")
		if err != nil {
			if verbose {
				displayerr("Can't export resource state", err)
			}
			return "", err
		}
		yamldoc += yamlfrag + "\n---\n"
	}
	return yamldoc, nil
}

// dump stores a YAML doc in a file in:
// $StateCacheDir/$status/
func dump(status, yamldoc string) (string, error) {
	targetdir := filepath.Join(StateCacheDir, status)
	if _, err := os.Stat(targetdir); os.IsNotExist(err) {
		_ = os.Mkdir(targetdir, os.ModePerm)
	}
	ts := time.Now().UnixNano()
	fn := filepath.Join(targetdir, "latest.yaml")
	// make sure we drop the cluster IP spec field for services:
	re := regexp.MustCompile("(?m)[\r\n]+^.*clusterIP:.*$")
	yamldoc = re.ReplaceAllString(yamldoc, "")
	// write out resulting YAML doc to file:
	err := ioutil.WriteFile(fn, []byte(yamldoc), 0644)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%v", ts), nil
}

// restorefrom applies resources from the YAML doc at:
// $StateCacheDir/$state/$timestamp_of_last_state_dump
func restorefrom(withstderr, verbose bool, state, tsLast string) (res string, err error) {
	statefile := filepath.Join(StateCacheDir, state, "latest.yaml")
	if verbose {
		fmt.Printf("Trying to restore state from %v/latest.yaml@%v\n", state, tsLast)
	}
	if _, err = os.Stat(statefile); !os.IsNotExist(err) {
		res, err = kubecuddler.Kubectl(withstderr, verbose, kubectlbin, "apply", "--filename="+statefile)
		if err != nil {
			if verbose {
				displayerr("Can't apply changes", err)
			}
			return "", err
		}
		if verbose {
			fmt.Printf("Successfully restored state:\n%v\n", res)
		}
	}
	return res, err
}

// use switches over to provided context as in:
// `kubectl config use-context minikube`
func use(withstderr, verbose bool, context string) error {
	_, err := kubecuddler.Kubectl(withstderr, verbose, kubectlbin, "config", "use-context", context)
	if err != nil {
		if verbose {
			displayerr("Can't switch context due", err)
		}
	}
	displayinfo(fmt.Sprintf("Now using context [%v]", context))
	return err
}
